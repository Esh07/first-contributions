name: Auto-merge PRs
on:
  pull_request_target:
    types: [opened, synchronize]
    paths:
      - 'Contributors.md' # <- only run if only contributors file changed
    
jobs:
  # Job for checking all modified files PR
  check-modified-files-and-content:
    id: check_files_modified_step
    runs-on: ubuntu-latest
    permissions:
      contents: read

    outputs:
      pr_files: ${{ steps.check_files_modified_step.outputs.pr_files }}
      files_changed: ${{ steps.check_files_modified_step.outputs.files_changed }}
      is_only_contributors_file_changed: ${{ steps.check_files_modified_step.outputs.only_contributors }}
      is_only_one_line_modified: ${{ steps.check_files_modified_step.outputs.only_one_line_edited }}
      contributors_md_content: ${{ steps.check_files_modified_step.outputs.contributors_md_content }}

    steps:
      - name: Checkout to PR branch
        uses: actions/checkout@v2
        with:
          ref: ${{ github.event.pull_request.head.sha }}
          fetch-depth: 2

      - name: Get PR files
        id: get_pr_files
        run: |
          # Get a list of files changed in the pull request
          PR_FILES=$(curl -s -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/${{ github.repository }}/pulls/${{ github.event.pull_request.number }}/files")

          # set the output 
          echo "pr_files=$PR_FILES" >> "$GITHUB_OUTPUT"

      # Check if the pull request only modifies the Contributors.md file
      - name: Check only Contributors.md file modified
        id: check_num_of_files_modified_step
        run: |
          # Extract the filenames from the API response
          FILES_CHANGED=$(echo "$PR_FILES" | jq -r '.[].filename')
          
          #FIXME: fix the logic for storing file name; currently, if there is space in the file name, it will be stored as two different files in the output. e.g "File name.md" will be stored as "File" and "name.md
          
          # file names as list
          FILES_CHANGED_LIST=$(echo $FILES_CHANGED)

          # file names stored in output
          echo "files_changed=$FILES_CHANGED_LIST" >> "$GITHUB_OUTPUT"

          # file names stored in env
          echo "files_changed=$FILES_CHANGED_LIST" >> $GITHUB_ENV

          # Look for Contributors.md file in the list of files changed
          if [[ "${FILES_CHANGED_LIST// /}" == "Contributors.md" ]]; then

            # share output with other workflow
            echo "only_contributors=true" >> "$GITHUB_OUTPUT" 

            # Content added to Contributors.md file
            CONTRIBUTORS_MD_CONTENT=$(echo "$PR_FILES" | jq -r '.[].patch')

            echo "contributors_md_content=$CONTRIBUTORS_MD_CONTENT" >> "$GITHUB_OUTPUT"

            #share env within step
            echo "only_contributors=true" >> $GITHUB_ENV

          else
            echo "only_contributors=false" >> "$GITHUB_OUTPUT"
          fi

      # Run only if there only Contributors.md file modified in the PR
      - name: Check only one line modified in Contributors.md
        id: check_num_of_lines_modified_step
        if: env.only_contributors == 'true'
        run: |
          # check only one line edited in Contributors.md file

          # Extract the additions and changes fields from the API response
          ADDITIONS=$(echo "$pr_files_url" | jq '.[] | select(.filename == "Contributors.md") | .additions')
          CHANGES=$(echo "$pr_files_url" | jq '.[] | select(.filename == "Contributors.md") | .changes')
          DELETIONS=$(echo "$pr_files_url" | jq '.[] | select(.filename == "Contributors.md") | .deletions')

          # check only one line added, or only one line changed, or only one line deleted and one line added which makes 2 number of changes in Contributors.md file

          if [[ ( $ADDITIONS -eq 1 && $CHANGES -eq 1 && $DELETIONS -eq 0 ) || ( $ADDITIONS -eq 1 && $CHANGES -eq 2 && $DELETIONS -eq 1 ) ]]; then

            # add to job output
            echo "only_one_line_edited=true" >> "$GITHUB_OUTPUT"

            # env variable
            echo "only_one_line_edited=true" >> $GITHUB_ENV

          else

            # More than one line was edited in Contributors.md file
            echo "only_one_line_edited=false" >> "$GITHUB_OUTPUT"

            echo "only_one_line_edited=false" >> $GITHUB_ENV

          fi

        env:
          pr_files_url: env.pr_files

  # Job for checking offensive and malicious links
  check-non-safe-content:
    if: env.get_is_only_contributors_file_changed == 'true' && get_is_only_one_line_modified = 'true'
    id: check_non_safe_content_step
    # job run after completion of this job
    needs: check-modified-files-and-content

    runs-on: ubuntu-latest

    permissions:
      # Only read permission to Github token
      contents: read

    outputs:
      is_safe_contents: ${{ steps.check_non_safe_content_step.outputs.is_safe_contents }}
      # replaced_safe_contents: ${{ steps.check_non_safe_content_step.outputs.replaced_safe_contents }}

    env:
      get_pr_files: ${{needs.check_files_modified_step.outputs.pr_files }}
      get_is_only_contributors_file_changed: ${{ needs.check_files_modified_step.outputs.only_contributors }}
      get_is_only_one_line_modified: ${{ needs.check_files_modified_step.outputs.only_one_line_edited }}
      get_contributors_md_content: ${{ needs.check_files_modified_step.outputs.contributors_md_content }}

    steps:
      - name: Separate the texts and links from the content
        id: separate_text_and_links_from_content
        run: |
          # get only the contents added in the PR 
          only_added_contents=$(echo "$get_contributors_md_content" | grep -oP '(?<=\+)(.*)(?=\n)')

          # get only the texts and links from the contents
          #only_added_links=$(echo "$only_added_contents" | grep -oP '(https?://)?(www\.)?[\w-]+\.[\w-]+(/[-\w./?%&=]*)?') 
          only_added_links=$(echo "$only_added_contents" | grep -oP '(https?://)?(www\.)?[\w-]+\.[\w-]+(/[-\w./?%&=]*)?' | tr '\n' ' ')

          # split the links into array
          array_of_threat_links=($only_added_links)

          # Extract text from the only_added_contents variable while ignoring links
          only_added_texts=$(echo "$only_added_contents" | grep -vE "$only_added_links" | grep -oP '[\w\s]+')

          # console log the texts and links
          echo "only_added_texts=$only_added_texts" 
          echo "only_added_links=$only_added_links"

          # set the env variables
          echo "only_added_texts=$only_added_texts" >> $GITHUB_ENV
          echo "only_added_links=$only_added_links" >> $GITHUB_ENV

          # set env variables for array of links
          echo "array_of_threat_links=${array_of_threat_links[@]}" >> $GITHUB_ENV

      #FIXME: There are no strict and reliable ways to check if the links are safe or not. The current implementation is using Google's Safe Browsing API to check if the links are safe. However, this is not a reliable solution as it only checks for the links that are already reported as malicious. We need to find a better solution for this.
      # - name: Check if the links are safe
      #   id: check_if_links_are_safe
      #   with:
      #     script: |
      #       # check with the Google's Safe Browsing API
      #       try{
      #         const response = await fetch('https://safebrowsing.googleapis.com/v4/threatMatches:find?key=${{ secrets.GOOGLE_SAFE_BROWSING_API_KEY }}', {
      #           method: 'POST',
      #           body: JSON.stringify({
      #             client: {
      #               clientId: 'first-contributions',
      #               clientVersion: '1.0.0'
      #             },
      #             threatInfo: {
      #               threatTypes: ['MALWARE', 'SOCIAL_ENGINEERING', 'UNWANTED_SOFTWARE', 'POTENTIALLY_HARMFUL_APPLICATION'],
      #               platformTypes: ['ANY_PLATFORM'],
      #               threatEntryTypes: ['URL'],
      #               "threatEntries": [
      #                 for url in "${{ env.array_of_threat_links }}" {
      #                   {
      #                     "url": "${{ url }}",
      #                   }
      #                 }
      #               ]
      #             }
      #           })
      #         })

      #         const data = await response.json()

      #         // check if the response is empty
      #         if (data.matches.length === 0) {
      #           console.log('No threats found in the links')
      #           core.setOutput('is_safe_contents_link', true)
      #         } else {
      #           console.log('Threats found in the links')
      #           core.setOutput('is_safe_contents_link', false)
      #         }
      #       } catch (error) {
      #         console.error("Error checking links:", error.message);
      #       }

      - name: Check inappropriate words in the texts
        id: check_inappropriate_words
        if: env.is_safe_contents_link == 'true'
        run: |
          # check if the texts contains inappropriate words
          try{
            const response = await fetch('https://www.purgomalum.com/service/containsprofanity?text=${{ env.only_added_texts }}')

            const data = await response.text()

            // check if the response is empty
            if (data === 'false') {
              console.log('No inappropriate words found in the texts')
              core.setOutput('is_safe_contents_text', true)
            } else {
              console.log('Inappropriate words found in the texts')
              core.setOutput('is_safe_contents_text', false)
            }
          } catch (error) {
            console.error("Error checking texts:", error.message);
          }

  merge-pr:
    if: env.is_safe_contents_text == 'true' && env.get_is_only_contributors_file_changed == 'true' && env.get_is_only_one_line_modified == 'true'
    id: merge_pr_step
    # job run after completion of this job
    needs: [check-modified-files-and-content, check-non-safe-content]

    runs-on: ubuntu-latest

    permissions:
      contents: write
      pull-requests: write

    outputs:
      is_pr_mergeable: ${{ steps.check_mergeability.outputs.is_pr_mergeable }}
      merge_check_error_message: ${{ steps.check_mergeability.outputs.merge_check_error_message }}
      is_merged_successfully: ${{ steps.merge_pr_step.outputs.is_merged_successfully }}
      merge_error_message: ${{ steps.merge_pr_step.outputs.merge_error_message }}

    env:
      get_pr_files: ${{needs.check_files_modified_step.outputs.pr_files }}
      get_is_only_contributors_file_changed: ${{ needs.check_files_modified_step.outputs.only_contributors }}
      get_is_only_one_line_modified: ${{ needs.check_files_modified_step.outputs.only_one_line_edited }}
      get_contributors_md_content: ${{ needs.check_files_modified_step.outputs.contributors_md_content }}

    steps:
      #Check mergeability of PR 
      - name: Check mergeability 
        id: check_mergeability
        uses: actions/github-script@v5
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            try{

              const {owner, repo} = context.repo;
              const pull_number = context.issue.number;

              let mergeable;

              let retries = 0;
              const maxRetries = 3; // Maximum number of retries

              // Keep checking the mergeability of the pull request until it is no longer null
              while (mergeable === null && retries < maxRetries) {

                const {data: pullRequest} = await github.rest.pulls.get({
                  owner,
                  repo,
                  pull_number
                });

                mergeable = pullRequest.mergeable;

                if (mergeable === null) {
                  // Wait 3 seconds before retrying the request
                  await new Promise(resolve => setTimeout(resolve, 3000));
                  retries++;
                }
              }

              if(retries === maxRetries) {
                console.log('Maximum number of retries exceeded. Mergeability is still null.')
                core.setOutput('is_pr_mergeable', false);
                core.setOutput('merge_check_error_message', 'Maximum number of retries exceeded. Mergeability is still null.');
              } else {
                console.log('Mergeability of the pull request:', mergeable)
                core.setOutput('is_merged_successfully', true);
              }

            } catch (error) {
              console.error("Error checking mergeability:", error.message);
            }

      # Close the PR if it contains offensive content
      - name: Close PR if it contains offensive content
        if: env.is_safe_contents == 'false'
        uses: actions/github-script@v5
        with:
          script: |
            try{
              github.rest.pulls.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: context.issue.number,
                state: 'closed'
              });

            } catch (error) {
              console.error("Error closing pull request:", error.message);
            }

      - name: Merge PR
        id: merge_pr
        if: env.get_is_only_contributors_file_changed == 'true' && env.get_is_only_one_line_modified == 'true' && env.is_safe_contents == 'true' && env.is_pr_mergeable == 'true'
        uses: actions/github-script@v5
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            try{
            // Attempt to merge the pull request using the squash method
             const response = await github.rest.pulls.merge({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number,
               merge_method: "squash"
             })

            // Check if the merge was successful by checking the status code of the response

              if (response.status === 200) {
                core.setOutput('is_merged_successfully', true);
              }

              } catch (error) {

              let errMsg = "";
              console.error("Error merging pull request:", error.message);

              // set the output error message
              core.setOutput('is_merged_successfully', false);
              core.setOutput('merge_error_message', error.message);

              }

      # Post a comment on the pull request if it was not merged automatically
      - name: Post comment on PR if not merged automatically
        # Check if the pull request only modifies the CONTRIBUTORS.md file
        if: env.only_contributors != 'true'
        uses: actions/github-script@v5
        with:
          script: |
            // get the existing comments.
            const {data: comments} = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.number,
            })

            // find any comment already made by the bot.                                                                                                    
            const botComment = comments.find(comment => comment.user.login === 'github-actions[bot]')                                                                       

            const body = `Thank you for your pull request. This pull request contains changes in files which requires review. The following files were changed:\n\n  ${process.env.files_changed.trim() ? `\n\n${process.env.files_changed.trim().split(' ').map(file => `- ${file}`).join('\n')}` : ''}`

            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: body
              })
            } else {
                await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: body
              });
            }
            
          github-token: ${{ secrets.GITHUB_TOKEN }}
